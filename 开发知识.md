# typing.Union 作用与用法

`from typing import Union` 用于在类型注解中表达“一个值可以是多种类型之一”。它提升了代码的自描述性，让 IDE、静态类型检查器（如 mypy、pyright）更好地理解你的意图，从而在开发阶段发现类型问题。

## 基本概念
- 联合类型：`Union[T1, T2, ...]` 表示值既可以是 `T1`，也可以是 `T2`，或其中任意一种。
- 常见示例：
  - 参数或返回值允许是 `int` 或 `float`：`Union[int, float]`
  - 容器中元素可能是多种类型：`list[Union[int, str]]`

## 项目中的示例
在本项目的 `test.py` 中：
```python
from typing import Union
Number = Union[int, float]

def power(a: Number, b: Number) -> float:
    return float(a) ** float(b)

def root(a: Number, b: Number) -> float:
    # 省略校验逻辑
    return (float(a)) ** (1.0 / float(b))
```
- 通过类型别名 `Number = Union[int, float]`，让函数签名更清晰，同时允许 `a`、`b` 接受整数或浮点数。

## 与 Optional 的关系
- `Optional[T]` 等价于 `Union[T, None]`。
- 示例：`Optional[int]` 即 `Union[int, None]`，表示值可以是整数或 `None`。

## Python 3.10+ 的简写
- 3.10 及以上版本支持使用管道符：`int | float` 等价于 `Union[int, float]`。
- 示例：`Number = int | float`。
- 建议在 3.10+ 项目中使用 `|`，更简洁、更易读。

## 运行时与检查器
- 运行时不做强制类型校验：`Union` 仅用于类型提示，Python 不会在运行时自动检查类型。
- 开发时受益：
  - IDE 自动补全更准确。
  - 静态检查器可在提交前发现类型不匹配。
- 若需要运行时校验，应主动使用 `isinstance()`、显式转换或自定义校验逻辑。

## 设计建议
- 使用类型别名简化复杂联合类型：
  - 如 `Params = Union[str, dict[str, str]]`。
- 避免过长的 `Union`，会降低可读性；若分支过多，考虑封装为类或统一为更抽象的类型。
- 返回值为多类型时，尽量为调用方提供稳定的结构（如统一返回字典或数据类），减少分支处理成本。

## 注意事项
- `Union` 的顺序不影响含义：`Union[int, str]` 与 `Union[str, int]` 等价。
- 如果联合中存在父子关系，检查器可能会简化类型：
  - 例如 `bool` 是 `int` 的子类，`Union[int, bool]` 可能被视为 `int`。
- 与 `Any` 的对比：
  - `Any` 表示“放弃检查”，任何类型都被接受；
  - `Union` 表示“限定在列举的类型集合内”，更安全。

## 与容器类型结合
- 在容器中使用联合类型描述更精确的结构：
```python
from typing import Union
rows: list[Union[int, str]] = [1, "a"]
conf: dict[str, Union[int, None]] = {"timeout": 30, "retries": None}
```

通过合理使用 `Union`，可以在不牺牲 Python 动态性的同时，让类型意图更明确，减少调试时间，提升代码质量。

---

# typing.Callable 作用与用法

`from typing import Callable` 用于为“**可调用对象**”（函数、方法、lambda、带 `__call__` 的类实例、`functools.partial` 等）进行类型注解，明确它的“参数类型列表”和“返回值类型”。

## 基本语法
- 形式：`Callable[[Arg1Type, Arg2Type, ...], ReturnType]`
- 示例：
```python
from typing import Callable

# 接受 (int, int) 参数，返回 int 的函数类型
Adder = Callable[[int, int], int]

def apply_add(x: int, y: int, f: Adder) -> int:
    return f(x, y)
```
- 不关心具体参数类型时：`Callable[..., ReturnType]`
```python
AnyFuncReturnsStr = Callable[..., str]
```

## 项目中的示例
在 `tool_add.py` 中：
```python
from typing import Union, Callable, Optional, Any
# function 参数既可以是可调用对象（Callable），也可以是字符串（代码内容）
def register_tool(self, name: str, description: str, function: Union[Callable, str], parameters: Optional[Any] = None):
    ...
```
- 含义：允许以两种方式注册工具：
  - 直接传入一个可调用的 Python 函数（如 `def my_tool(...): ...`）。
  - 传入代码字符串，由系统后续解析/评审/执行。
- 好处：通过 `Union[Callable, str]` 清晰表达参数的多态性，同时让静态检查器和 IDE 更好地推断用法。

## 高级用法：捕获“任意签名”
- 当需要编写“高阶函数”（接受并返回可调用对象），可用 `ParamSpec` 表达“调用参数签名”，用 `TypeVar` 表达“返回值类型”：
```python
from typing import Callable, TypeVar
from typing_extensions import ParamSpec  # Python <3.10 可用 typing_extensions

P = ParamSpec('P')
R = TypeVar('R')

def log_calls(func: Callable[P, R]) -> Callable[P, R]:
    def wrapper(*args: P.args, **kwargs: P.kwargs) -> R:
        print('calling', func.__name__)
        return func(*args, **kwargs)
    return wrapper
```
- 作用：在保留原函数参数签名和返回类型的同时，包装出新函数，IDE/检查器仍能准确推断。

## 注意事项与建议
- 运行时不强制验证：`Callable` 是类型提示，若需在运行时校验可使用 `callable(obj)` 或 `inspect.signature`。
- 参数列表需与实际函数保持一致；若不确定具体参数，使用 `Callable[..., ReturnType]`。
- 与 `Union` 搭配能表达更灵活的 API（如 `Union[Callable, str]`）。
- 对复杂回调类型，优先定义类型别名，提升可读性与复用性。

---

# `_convert_string_to_function` 使用介绍（tool_add.py）

函数签名（当前实现）：
```python
def _convert_string_to_function(self, code_content: str, tool_name: Optional[str] = None) -> Callable:
    ...
```

**作用**
- 将“字符串形式的函数代码”转换为一个"**可调用函数对象**"，用于动态注册工具。
- 在 Python 里，函数本身就是对象
**工作原理**
- 在一个独立命名空间 `local_namespace = {}` 中执行：`exec(code_content, globals(), local_namespace)`。
- 按名称优先提取：若传入 `tool_name`，会先尝试 `local_namespace.get(tool_name)`，命中且满足条件（可调用、非内建、名称不以下划线开头）则直接返回该函数。
- 若未命中，再回退到“命名空间中第一个符合条件的可调用对象”。
- 找不到符合条件的函数时抛出 `ValueError("无法从代码字符串中提取函数")`。

**与 `register_tool` 的配合**
- 当你调用 `register_tool(tool_name, description, function=code_str, parameters=...)` 且 `function` 是字符串时，内部会自动调用 `_convert_string_to_function(code_str, tool_name)`：
  - 这意味着如果代码字符串中定义的函数名与 `tool_name` 一致，将被优先选中；否则回退到第一个函数。

**示例**
```python
code_str = """
import math

def circle_area(radius: float) -> float:
    return math.pi * radius * radius
"""

# 以 tool_name 优先匹配同名函数
register_tool(
    tool_name="circle_area",
    description="计算圆面积",
    function=code_str  # 字符串形式，内部将按 tool_name 优先提取 circle_area
)
```

**注意事项（安全与健壮性）**
- 代码字符串会被执行：请确保来源可信，避免注入恶意代码。
- 服务端接口（`/api/tools`）已包含安全审查（`security_review.review_tool_code`），但本地或绕过接口仍需谨慎。
- 命名要求：若希望按名提取，请确保函数名与 `tool_name` 一致，且不以下划线开头；否则将回退到第一个符合条件的函数（可能不是你期望的）。

